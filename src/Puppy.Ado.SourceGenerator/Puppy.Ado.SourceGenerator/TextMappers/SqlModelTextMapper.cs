using System;
using System.Linq;
using Puppy.Ado.SourceGenerator.Models;

namespace Puppy.Ado.SourceGenerator
{
    public class SqlModelTextMapper
    {
        public static string EmitView(ViewModel v)
        {
            var dtoName = $"{v.ClrName}_Row";
            var props = string.Join("\n", v.Columns.Select(c =>
                $"    public {ClrTypeMapper.ToClrType(c.SqlType, c.IsNullable)} {ToPascal(c.Name)} {{ get; init; }}"));

            var readCols = string.Join("\n", v.Columns.Select((c, i) =>
                c.IsNullable && IsValueType(c.SqlType) ?
                    $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? default({ClrTypeMapper.ToClrType(c.SqlType, true)}) : reader.{GetReaderMethod(c.SqlType)}({i}),"
                    : c.IsNullable && !IsValueType(c.SqlType) ?
                        $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? null : reader.{GetReaderMethod(c.SqlType)}({i}),"
                        :
                        $"                {ToPascal(c.Name)} = reader.{GetReaderMethod(c.SqlType)}({i}),"));

            //language: csharp
            return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;

public sealed class {dtoName}
{{
{props}
}}

public partial class {v.ClrName}_ViewClient
{{
    
    private readonly string _connectionString;
    private readonly bool _useDefaultRetryOptions;
    public dbo_spEnrollStudent_ProcClient(string connectionString,
        bool useDefaultRetryOptions)
    {{
        _connectionString = connectionString;
        _useDefaultRetryOptions = useDefaultRetryOptions;
    }}

    public async Task<List<{dtoName}>> QueryAsync(
        DbConnection? existingConnection = null,
        CancellationToken ct = default)
    {{
        DbConnection? connection = existingConnection;
        if (connection == null)
        {{
            connection = new SqlConnection(_connectionString);
        }}
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT {string.Join(", ", v.Columns.Select(c => $"[{c.Name}]"))} FROM {v.FullName}"";
        cmd.CommandType = CommandType.Text;

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<{dtoName}>(capacity: 256);

        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {{
            list.Add(new {dtoName}
            {{
{readCols}
            }});
        }}

        if (existingConnection == null)
        {{
            connection.Dispose();
        }}
        return list;
    }}
}}";
        }

        public static string EmitFunction(FunctionModel f)
        {
            if (f.IsTableValued)
            {
                var dtoName = $"{f.ClrName}_Row";
                var props = string.Join("\n", f.TableColumns.Select(c =>
                    $"    public {ClrTypeMapper.ToClrType(c.SqlType, c.IsNullable)} {ToPascal(c.Name)} {{ get; init; }}"));

                var addParams = string.Join("\n", f.Parameters.Select(par =>
                    $"        AddParam(cmd, \"{par.Name}\", System.Data.SqlDbType.{ToSqlDbType(par.SqlType)}, input.{ToPascal(TrimAt(par.Name))}, false);"));

                var readCols = string.Join("\n", f.TableColumns.Select((c, i) =>
                    c.IsNullable && IsValueType(c.SqlType) ?
                        $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? default({ClrTypeMapper.ToClrType(c.SqlType, true)}) : reader.{GetReaderMethod(c.SqlType)}({i}),"
                        : c.IsNullable && !IsValueType(c.SqlType) ?
                            $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? null : reader.{GetReaderMethod(c.SqlType)}({i}),"
                            :
                            $"                {ToPascal(c.Name)} = reader.{GetReaderMethod(c.SqlType)}({i}),"));

                var inputDtoName = $"{f.ClrName}_Input";
                var paramProps = string.Join("\n", f.Parameters.Select(par =>
                    $"    public {ClrTypeMapper.ToClrType(par.SqlType, par.IsNullable)} {ToPascal(TrimAt(par.Name))} {{ get; init; }}"));

                return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Data.SqlClient;

public sealed class {inputDtoName}
{{
{paramProps}
}}

public sealed class {dtoName}
{{
{props}
}}

public static partial class {f.ClrName}_FunctionClient
{{
    public static async Task<List<{dtoName}>> QueryAsync(DbConnection connection, {inputDtoName} input, CancellationToken ct = default)
    {{
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT * FROM {f.FullName}({string.Join(", ", f.Parameters.Select(p => p.Name))})"";
        cmd.CommandType = CommandType.Text;

{addParams}

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<{dtoName}>(capacity: 256);

        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {{
            list.Add(new {dtoName}
            {{
{readCols}
            }});
        }}

        return list;
    }}
}}";
            }
            else
            {
                var inputDtoName = $"{f.ClrName}_Input";
                var paramProps = string.Join("\n", f.Parameters.Select(par =>
                    $"    public {ClrTypeMapper.ToClrType(par.SqlType, par.IsNullable)} {ToPascal(TrimAt(par.Name))} {{ get; init; }}"));

                var addParams = string.Join("\n", f.Parameters.Select(par =>
                    $"        AddParam(cmd, \"{par.Name}\", System.Data.SqlDbType.{ToSqlDbType(par.SqlType)}, input.{ToPascal(TrimAt(par.Name))}, false);"));

                var clrRet = ClrTypeMapper.ToClrType(f.ScalarReturn ?? SqlType.Int(), true);

                return $@"// <auto-generated />
using System;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public sealed class {inputDtoName}
{{
{paramProps}
}}

public static partial class {f.ClrName}_FunctionClient
{{
    public static async Task<{clrRet}> ExecuteAsync(DbConnection connection, {inputDtoName} input, CancellationToken ct = default)
    {{
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT {f.FullName}({string.Join(", ", f.Parameters.Select(p => p.Name))})"";
        cmd.CommandType = CommandType.Text;

{addParams}

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return result is DBNull or null ? default! : ({clrRet})Convert.ChangeType(result, typeof({clrRet}));
    }}
}}";
            }
        }
        
        public static string ToPascal(string name)
        {
            var n = TrimAt(name).Trim('[', ']', '@');
            return string.Concat(n.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1)));
        }

        public static string TrimAt(string name) => name.Trim().TrimStart('@');

        public static bool IsValueType(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n is "smallint" or "int" or "bigint" or "bit" or "uniqueidentifier" or "decimal" or "numeric" or "float" or "real" or "date" or "datetime2" or "datetimeoffset";
        }

        public static string GetReaderMethod(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n switch
            {
                "smallint" => "GetInt16",
                "int" => "GetInt32",
                "bigint" => "GetInt64",
                "bit" => "GetBoolean",
                "uniqueidentifier" => "GetGuid",
                "decimal" or "numeric" => "GetDecimal",
                "float" => "GetDouble",
                "real" => "GetFloat",
                "date" or "datetime2" => "GetDateTime",
                "datetimeoffset" => "GetFieldValue<System.DateTimeOffset>",
                "varbinary" => "GetFieldValue<byte[]>",
                "varchar" or "nvarchar" or "nchar" or "xml" => "GetString",
                _ => "GetValue"
            };
        }

        public static string ToSqlDbType(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n switch
            {
                "smallint" => "SmallInt",
                "int" => "Int",
                "bigint" => "BigInt",
                "bit" => "Bit",
                "uniqueidentifier" => "UniqueIdentifier",
                "decimal" => "Decimal",
                "numeric" => "Decimal",
                "float" => "Float",
                "real" => "Real",
                "date" => "Date",
                "datetime2" => "DateTime2",
                "datetimeoffset" => "DateTimeOffset",
                "varbinary" => "VarBinary",
                "varchar" => "VarChar",
                "nvarchar" => "NVarChar",
                "nchar" => "NChar",
                "xml" => "Xml",
                _ => "VarChar"
            };
        }
    }
}