using System;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Puppy.Ado.SourceGenerator
{
    [Generator]
    public sealed class DbGenFromInfoSchema : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var options = context.AnalyzerConfigOptionsProvider.Select(
                (p, _) => new GeneratorOptions(p));
            var modelProvider = options.Select( (o, ct) =>
            {
                if (!o.EnableLiveSchema || string.IsNullOrWhiteSpace(o.ConnectionString))
                    return null;

                var reader = new SqlServerSchemaReaderSync(o.ConnectionString!);
                return reader.Read();
            });

            context.RegisterSourceOutput(modelProvider, (spc, model) =>
            {
                if (model is null) return;

                foreach (var v in model.Views)
                    spc.AddSource($"{v.ClrName}.View.g.cs", EmitView(v));

                foreach (var f in model.Functions)
                    spc.AddSource($"{f.ClrName}.Function.g.cs", EmitFunction(f));

                foreach (var p in model.StoredProcedures)
                    spc.AddSource($"{p.ClrName}.Procedure.g.cs", EmitProcedure(p));
            });
        }

        public static string EmitView(ViewModel v)
        {
            var dtoName = $"{v.ClrName}_Row";
            var props = string.Join("\n", v.Columns.Select(c =>
                $"    public {ClrTypeMapper.ToClrType(c.SqlType, c.IsNullable)} {ToPascal(c.Name)} {{ get; init; }}"));

            var readCols = string.Join("\n", v.Columns.Select((c, i) =>
                c.IsNullable && IsValueType(c.SqlType) ?
                    $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? default({ClrTypeMapper.ToClrType(c.SqlType, true)}) : reader.{GetReaderMethod(c.SqlType)}({i}),"
                    : c.IsNullable && !IsValueType(c.SqlType) ?
                        $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? null : reader.{GetReaderMethod(c.SqlType)}({i}),"
                        :
                        $"                {ToPascal(c.Name)} = reader.{GetReaderMethod(c.SqlType)}({i}),"));

            //language: csharp
            return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public sealed class {dtoName}
{{
{props}
}}

public partial class {v.ClrName}_ViewClient
{{
    
    private readonly string _connectionString;
    private readonly bool _useDefaultRetryOptions;
    public dbo_spEnrollStudent_ProcClient(string connectionString,
        bool useDefaultRetryOptions)
    {{
        _connectionString = connectionString;
        _useDefaultRetryOptions = useDefaultRetryOptions;
    }}

    public async Task<List<{dtoName}>> QueryAsync(
        DbConnection? existingConnection = null,
        CancellationToken ct = default)
    {{
        DbConnection? connection = existingConnection;
        if (connection == null)
        {{
            connection = new SqlConnection(_connectionString);
        }}
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT {string.Join(", ", v.Columns.Select(c => $"[{c.Name}]"))} FROM {v.FullName}"";
        cmd.CommandType = CommandType.Text;

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<{dtoName}>(capacity: 256);

        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {{
            list.Add(new {dtoName}
            {{
{readCols}
            }});
        }}

        if (existingConnection == null)
        {{
            connection.Dispose();
        }}
        return list;
    }}
}}";
        }

        public static string EmitProcedure(StoredProcedureModel p)
        {
            var inputDtoName = $"{p.ClrName}_Input";
            var outputDtoName = $"{p.ClrName}_Row";
            var paramProps = string.Join("\n", p.Parameters.Select(par =>
                $"    public {par.ClrName} {ToPascal(TrimAt(par.Name))} {{ get; init; }}"));

            var addParams = string.Join("\n", p.Parameters.Select(par =>
                par.IsTableValued && par.TableTypeFullName is not null
                    ? $"        cmd.Parameters.Add(ToTvp(\"{par.Name}\", \"{par.TableTypeFullName}\", input.{ToPascal(TrimAt(par.Name))}));"
                    : $"        AddParam(cmd, \"{par.Name}\", System.Data.SqlDbType.{ToSqlDbType(par.SqlType)}, input.{ToPascal(TrimAt(par.Name))}, {par.IsOutput.ToString().ToLowerInvariant()});"));

            var hasResult = p.ResultSets.FirstOrDefault();
            var dtoProps = hasResult is null ? "" :
                string.Join("\n", hasResult.Columns.Select(c =>
                    $"    public {ClrTypeMapper.ToClrType(c.SqlType, c.IsNullable)} {ToPascal(c.Name)} {{ get; init; }}"));

            var readCols = hasResult is null ? "" :
                string.Join("\n", hasResult.Columns.Select((c, i) =>
                    c.IsNullable && IsValueType(c.SqlType) ?
                        $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? default({ClrTypeMapper.ToClrType(c.SqlType, true)}) : reader.{GetReaderMethod(c.SqlType)}({i}),"
                        : c.IsNullable && !IsValueType(c.SqlType) ?
                            $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? null : reader.{GetReaderMethod(c.SqlType)}({i}),"
                            :
                            $"                {ToPascal(c.Name)} = reader.{GetReaderMethod(c.SqlType)}({i}),"));

            var readBlock = hasResult is null ? "await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);\n        return new List<object>(0);" : $@"
        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<{outputDtoName}>(capacity: 64);
        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {{
            list.Add(new {outputDtoName}
            {{
{readCols}
            }});
        }}
        if (existingConnection == null)
        {{
            connection.Dispose();
        }}
        return list;";

            return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using System.Data.SqlClient;

public sealed class {inputDtoName}
{{
{paramProps}
}}

{(hasResult is null ? "" : $@"public sealed class {outputDtoName}
{{
{dtoProps}
}}")}

public partial class {p.ClrName}_ProcClient
{{
    private readonly string _connectionString;
    private readonly bool _useDefaultRetryOptions;
    public {p.ClrName}_ProcClient(string connectionString,
        bool useDefaultRetryOptions)
    {{
        _connectionString = connectionString;
        _useDefaultRetryOptions = useDefaultRetryOptions;
    }}

    public async Task<List<{(hasResult is null ? "object" : outputDtoName)}>> ExecuteAsync(
        DbConnection connection,
        {inputDtoName} input,
        DbConnection? existingConnection = null,
        CancellationToken ct = default)
    {{
        DbConnection? connection = existingConnection;
        if (connection == null)
        {{
            connection = new SqlConnection(_connectionString);
        }}
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""{p.FullName}"";
        cmd.CommandType = CommandType.StoredProcedure;

{addParams}

        OnBeforeExecute?.Invoke(cmd);

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

{readBlock}
    }}

    public Action<DbCommand>? OnBeforeExecute {{ get; set; }}

    private static void AddParam(DbCommand cmd, string name, System.Data.SqlDbType sqlDbType, object? value, bool isOutput)
    {{
        var p = new SqlParameter(name, sqlDbType)
        {{
            Direction = isOutput ? ParameterDirection.InputOutput : ParameterDirection.Input,
            Value = value ?? DBNull.Value
        }};
        cmd.Parameters.Add(p);
    }}

    private static SqlParameter ToTvp<T>(string name, string typeName, IEnumerable<T> rows)
    {{
        var table = new System.Data.DataTable();
        // TVP DataTable columns are emitted elsewhere; customize as needed via partial hook.
        foreach (var r in rows)
            table.Rows.Add(r); // For records/tuples; otherwise build rows explicitly.

        return new SqlParameter(name, SqlDbType.Structured) {{ TypeName = typeName, Value = table }};
    }}
}}";
        }

        public static string EmitFunction(FunctionModel f)
        {
            if (f.IsTableValued)
            {
                var dtoName = $"{f.ClrName}_Row";
                var props = string.Join("\n", f.TableColumns.Select(c =>
                    $"    public {ClrTypeMapper.ToClrType(c.SqlType, c.IsNullable)} {ToPascal(c.Name)} {{ get; init; }}"));

                var addParams = string.Join("\n", f.Parameters.Select(par =>
                    $"        AddParam(cmd, \"{par.Name}\", System.Data.SqlDbType.{ToSqlDbType(par.SqlType)}, input.{ToPascal(TrimAt(par.Name))}, false);"));

                var readCols = string.Join("\n", f.TableColumns.Select((c, i) =>
                    c.IsNullable && IsValueType(c.SqlType) ?
                        $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? default({ClrTypeMapper.ToClrType(c.SqlType, true)}) : reader.{GetReaderMethod(c.SqlType)}({i}),"
                        : c.IsNullable && !IsValueType(c.SqlType) ?
                            $"                {ToPascal(c.Name)} = reader.IsDBNull({i}) ? null : reader.{GetReaderMethod(c.SqlType)}({i}),"
                            :
                            $"                {ToPascal(c.Name)} = reader.{GetReaderMethod(c.SqlType)}({i}),"));

                var inputDtoName = $"{f.ClrName}_Input";
                var paramProps = string.Join("\n", f.Parameters.Select(par =>
                    $"    public {ClrTypeMapper.ToClrType(par.SqlType, par.IsNullable)} {ToPascal(TrimAt(par.Name))} {{ get; init; }}"));

                return $@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public sealed class {inputDtoName}
{{
{paramProps}
}}

public sealed class {dtoName}
{{
{props}
}}

public static partial class {f.ClrName}_FunctionClient
{{
    public static async Task<List<{dtoName}>> QueryAsync(DbConnection connection, {inputDtoName} input, CancellationToken ct = default)
    {{
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT * FROM {f.FullName}({string.Join(", ", f.Parameters.Select(p => p.Name))})"";
        cmd.CommandType = CommandType.Text;

{addParams}

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<{dtoName}>(capacity: 256);

        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {{
            list.Add(new {dtoName}
            {{
{readCols}
            }});
        }}

        return list;
    }}
}}";
            }
            else
            {
                var inputDtoName = $"{f.ClrName}_Input";
                var paramProps = string.Join("\n", f.Parameters.Select(par =>
                    $"    public {ClrTypeMapper.ToClrType(par.SqlType, par.IsNullable)} {ToPascal(TrimAt(par.Name))} {{ get; init; }}"));

                var addParams = string.Join("\n", f.Parameters.Select(par =>
                    $"        AddParam(cmd, \"{par.Name}\", System.Data.SqlDbType.{ToSqlDbType(par.SqlType)}, input.{ToPascal(TrimAt(par.Name))}, false);"));

                var clrRet = ClrTypeMapper.ToClrType(f.ScalarReturn ?? SqlType.Int(), true);

                return $@"// <auto-generated />
using System;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

public sealed class {inputDtoName}
{{
{paramProps}
}}

public static partial class {f.ClrName}_FunctionClient
{{
    public static async Task<{clrRet}> ExecuteAsync(DbConnection connection, {inputDtoName} input, CancellationToken ct = default)
    {{
        using var cmd = connection.CreateCommand();
        cmd.CommandText = ""SELECT {f.FullName}({string.Join(", ", f.Parameters.Select(p => p.Name))})"";
        cmd.CommandType = CommandType.Text;

{addParams}

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return result is DBNull or null ? default! : ({clrRet})Convert.ChangeType(result, typeof({clrRet}));
    }}
}}";
            }
        }

        private sealed class GeneratorOptions
        {
            public bool EnableLiveSchema { get; }
            public string? ConnectionString { get; }

            public GeneratorOptions(AnalyzerConfigOptionsProvider provider)
            {
                var global = provider.GlobalOptions;
                global.TryGetValue("build_property.DbGen_EnableLiveSchema", out var enable);
                global.TryGetValue("build_property.DbGen_ConnectionString", out var conn);
                EnableLiveSchema = bool.TryParse(enable, out var b) && b;
                ConnectionString = conn;
            }
        }

        private static string ToPascal(string name)
        {
            var n = TrimAt(name).Trim('[', ']', '@');
            return string.Concat(n.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1)));
        }

        private static string TrimAt(string name) => name.Trim().TrimStart('@');

        private static bool IsValueType(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n is "int" or "bigint" or "bit" or "uniqueidentifier" or "decimal" or "numeric" or "float" or "real" or "date" or "datetime2" or "datetimeoffset";
        }

        private static string GetReaderMethod(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n switch
            {
                "int" => "GetInt32",
                "bigint" => "GetInt64",
                "bit" => "GetBoolean",
                "uniqueidentifier" => "GetGuid",
                "decimal" or "numeric" => "GetDecimal",
                "float" => "GetDouble",
                "real" => "GetFloat",
                "date" or "datetime2" => "GetDateTime",
                "datetimeoffset" => "GetFieldValue<System.DateTimeOffset>",
                "varbinary" => "GetFieldValue<byte[]>",
                "varchar" or "nvarchar" or "nchar" or "xml" => "GetString",
                _ => "GetValue"
            };
        }

        private static string ToSqlDbType(SqlType t)
        {
            var n = t.Name.ToLowerInvariant();
            return n switch
            {
                "int" => "Int",
                "bigint" => "BigInt",
                "bit" => "Bit",
                "uniqueidentifier" => "UniqueIdentifier",
                "decimal" => "Decimal",
                "numeric" => "Decimal",
                "float" => "Float",
                "real" => "Real",
                "date" => "Date",
                "datetime2" => "DateTime2",
                "datetimeoffset" => "DateTimeOffset",
                "varbinary" => "VarBinary",
                "varchar" => "VarChar",
                "nvarchar" => "NVarChar",
                "nchar" => "NChar",
                "xml" => "Xml",
                _ => "VarChar"
            };
        }
    }
}