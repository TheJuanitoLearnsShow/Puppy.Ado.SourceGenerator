// <auto-generated />
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using System.Data.SqlClient;

public sealed class dbo_spEnrollStudent_Input
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public short Age { get; init; }
    public (string LocationName, int Level)[] ClassesToEnroll { get; init; }
}

public sealed class dbo_spEnrollStudent_Row
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public int? Age { get; init; }
}

public partial class dbo_spEnrollStudent_ProcClient
{
    private readonly string _connectionString;
    private readonly bool _useDefaultRetryOptions;
    public dbo_spEnrollStudent_ProcClient(string connectionString,
        bool useDefaultRetryOptions)
    {
        _connectionString = connectionString;
        _useDefaultRetryOptions = useDefaultRetryOptions;
    }

    public async Task<List<dbo_spEnrollStudent_Row>> ExecuteAsync(
        dbo_spEnrollStudent_Input input,
        DbConnection? existingConnection = null,
        CancellationToken ct = default)
    {
        DbConnection? connection = existingConnection;
        if (connection == null)
        {
            connection = new SqlConnection(_connectionString);
        }
        using var cmd = connection.CreateCommand();
        cmd.CommandText = "[dbo].[spEnrollStudent]";
        cmd.CommandType = CommandType.StoredProcedure;

        AddParam(cmd, "@FirstName", System.Data.SqlDbType.VarChar, input.FirstName, false);
        AddParam(cmd, "@LastName", System.Data.SqlDbType.VarChar, input.LastName, false);
        AddParam(cmd, "@Age", System.Data.SqlDbType.SmallInt, input.Age, false);
        cmd.Parameters.Add(ToTvp("@ClassesToEnroll", "[dbo].[ClassesType]", input.ClassesToEnroll));

        OnBeforeExecute?.Invoke(cmd);

        if (connection.State != ConnectionState.Open)
            await connection.OpenAsync(ct).ConfigureAwait(false);


        using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess, ct).ConfigureAwait(false);
        var list = new List<dbo_spEnrollStudent_Row>(capacity: 64);
        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {
            list.Add(new dbo_spEnrollStudent_Row
            {
                FirstName = reader.IsDBNull(0) ? null : reader.GetString(0),
                LastName = reader.IsDBNull(1) ? null : reader.GetString(1),
                Age = reader.IsDBNull(2) ? default(int?) : reader.GetInt32(2),
            });
        }
        if (existingConnection == null)
        {
            connection.Dispose();
        }
        return list;
    }

    public Action<DbCommand>? OnBeforeExecute { get; set; }

    private static void AddParam(DbCommand cmd, string name, System.Data.SqlDbType sqlDbType, object? value, bool isOutput)
    {
        var p = new SqlParameter(name, sqlDbType)
        {
            Direction = isOutput ? ParameterDirection.InputOutput : ParameterDirection.Input,
            Value = value ?? DBNull.Value
        };
        cmd.Parameters.Add(p);
    }

    private static SqlParameter ToTvp<T>(string name, string typeName, IEnumerable<T> rows)
    {
        var table = new System.Data.DataTable();
        // TVP DataTable columns are emitted elsewhere; customize as needed via partial hook.
        foreach (var r in rows)
            table.Rows.Add(r); // For records/tuples; otherwise build rows explicitly.

        return new SqlParameter(name, SqlDbType.Structured) { TypeName = typeName, Value = table };
    }
}